---
output: html_document
editor_options: 
  chunk_output_type: inline
---


# (PART\*) Illuminate {-}

# Use General Principles of High-Quality Data Viz in R {-}

In the spring of 2021, [nearly all of the American West was in a drought](https://droughtmonitor.unl.edu/DmData/TimeSeries.aspx). In April of that year, [officials in Southern California declared a water emergency](https://www.cbsnews.com/news/west-climate-change-water/), citing unprecedented conditions. 

This wouldn't have come as news to those living in California and other Western states. In addition to the direct impact of drought (leading areas of California to implement water use restrictions), people could see the indirect impact of drought in increased wildfires. With forests dried out by years of drought conditions, wildfires became more frequent, filling skies in the West with smoke. 

TODO: Add personal story

While more and more people are able to see the increase in drought conditions, communicating the extent of this change remains a challenge. How can we show the data in a way that accurately represents the data while is also compelling enough to have lay people take notice? 

This was the challenge that freelance data visualization designers Cédric Scherer and Georgios Karamanis took on in November 2021. Commissioned by the magazine Scientific American to create a data visualization that would highlight the extent to which droughts in the United States have become common, they turned to the ggplot2 package to turn what could be (pardon the pun) dry data on droughts into a set of impactful data visualizations. 

There was nothing unique about the data that Cédric and Georgios used. It was the same data from the National Drought Center that news organizations used in their stories. But what these two information designers did was visualize the data in a way that it both grabs attention and communicates clearly the scale of the phenomenon. 

## Close read of viz to show why it's effective

To understand why this visualization is effective, let's break it down into pieces. 

At the broadest level, what we see as a single chart is actually a set of charts. Each rectangle represents one year in one region.

TODO: Add image

Looking at this single visualization of one year in one region, we can see that the x axis shows the week while the y axis shows the percentage of that region at different drought levels. 

TODO: Add image

The stacked bars also use color to show the different drought levels. The lightest bar shows the percentage of the region that is abnormally dry while the darkest bar shows the percentage in exceptional drought conditions. 

TODO: Add image

The data viz is also notable for its minimalist aesthetic. There are, for example, no grid lines, only a simple gray background for each small multiple. This minimalist aesthetic is not just a personal preference. Research on data visualization consistently shows that removing extraneous elements allows readers to better understand the data being visualized (TODO: Add references). 

TODO: Add image

When I asked Cédric and Georgios to speak with me about this data visualization, they initially told me that the code for this piece might be too simple to highlight the power of R for data viz. No, I told them, I want to speak with you precisely *because* the code is not super complex. The fact that Cédric and Georgios were able to produce this complex graph with relatively simple code shows the power of R for data visualization. And this is made possible because of a theory called the grammar of graphics.

## The grammar of graphics

If you've used Excel to make graphs, you're probably familiar with this menu: 

TODO: Add image https://show.rfor.us/UewnER

Working in Excel, your graph-making journey begins with the step of selecting the type of graph you want to make. If you've only ever made data visualization in Excel, this first step may seem so obvious that you've never even considered conceptualizing the process of creating data visualization in any different way. This was certainly the case for me in my years as an Excel user.

TODO: Switch to saying that there's another way to think about making a graph (by starting to think about aesthetic properties)

But some people think of data visualization at a much deeper level. One of these was the late statistician Leland Wilkinson. Wilkinson thought deeply for years about what data visualization is and how we can describe it. In 1999, he published a book called *The Grammar of Graphics* that sought to develop a consistent way of describing *all* graphs. 

Wilkinson argued that we should think of plots not as distinct types a la Excel, but as following a grammar that we can use to describe *any* plot. Throughout the book that Wilkinson is best remembered for, he presented general principles to describe graphs. Just as knowledge of English grammar tells us that a noun followed by a verb ("he goes") works while the opposite ("goes he") does not, knowledge of the grammar of graphics allows us to understand why certain graph types "work." Or, as Wilkinson put it,

> A language consisting of words and no grammar (statement = word) expresses only as many ideas as there are words. ... The grammar of graphics takes us beyond a limited set of charts (words) to an almost unlimited world of graphical forms (statements). 

Thinking about data visualization through the lens of the grammar of graphics allow us to see that graphs typically have data that is plotted on the x axis and other data that is plotted on the y axis. And this is the case no matter whether the type of graph we end up with is, to take just two examples, a bar chart of a line chart. Consider these two graphs:

TODO: Add images of bar chart and line chart showing same data

While they look different (and would, to the Excel user, be different types of graphs), Wilkinson's grammar of graphics allows us to see similarities in them. 

As an academic statistician, Wilkinson's goal in writing *The Grammar of Graphics* was to provide a novel way of thinking about data visualization. But his feelings on graph-making tools like Excel were clear when he wrote that "most charting packages channel user requests into a rigid array of chart types. To atone for this lack of flexibility, they offer a kit of post-creation editing tools to return the image to what the user originally envisioned."

The answer to this unspoken request for product would come in 2010, when [Hadley Wickham announced the `ggplot2` package for R](https://vita.had.co.nz/papers/layered-grammar.html). Implementing Wilkinson's ideas not only to describe graphs, but also providing the tools to make them, `ggplot2` would come to revolutionize the world of data visualization. 

## ggplot2

Hadley Wickham's article announcing `ggplot2` (which I, like nearly everyone in the data viz world, will refer to simply as ggplot) was titled "A Layered Grammar of Graphics." This idea of layering graphical elements is key to understanding how ggplot works. Let's walk through some of the most important layers. 

When creating a graph with ggplot, we begin by mapping data to aesthetic properties. To the uninitiated, this may sound like complete nonsense. But all it means is that we use things like the x or y axis, color, size (aka aesthetic properties) to represent variables. 

Let's use some data to make this concrete. Below are 10 (out of over 1,700 total) rows of data from the gapminder dataset made famous by Swedish TODO: add background on him Hans Rosling (TODO: cite). 

```{r}
library(gapminder)
library(tidyverse)
library(lubridate)
library(sf)
library(albersusa)
library(colorspace)
library(shades)
library(systemfonts)
```

```{r}
gapminder_10_rows <- gapminder %>% 
  slice(1:10)
```

```{r}
gapminder_10_rows
```

If we want to make a chart, we need to first decide which variable to use to put on the x axis and which to put on the y axis. Let's say we want to show life expectancy over time. That means using the variable `year` on the x axis and the variable `lifeExp` on the y axis. 



I begin by using the `ggplot()` function. Within this, I tell R that I'm using the data frame `gapminder_10_rows` (this is the shortened version I saved from the full `gapminder` data frame). The line following this tells R to use `year` on the x and `lifeExp` on the y axis. When I run my code, what I get doesn't look like much.

```{r}
ggplot(data = gapminder_10_rows,
       mapping = aes(x = year,
                     y = lifeExp))
```

But if I look closely, I can see the beginnings of a plot. Remember that x axis using `year`? There it is! And `lifeExp` on the y axis? Yup, it's there too. 

I can also see that the values on the x and y axes match up to our data. In the `gapminder_10_rows` data frame, the first year is 1952 and the last year is 1997. The range of the x axis seems to have been created with this data in mind (spoiler: it was). And `lifeExp`, which goes from about 28 to about 42 will fit nicely on our y axis.

Axes are nice, but we're missing any type of visual representation of the data. To get this, we need to add the next layer in ggplot: geoms. geoms, short for geometric objects, are different ways of representing data. For example, if we want to add points, we use `geom_point()`. 

```{r}
ggplot(data = gapminder_10_rows,
       mapping = aes(x = year,
                     y = lifeExp)) +
  geom_point()
```
There we go! 1952 shows the life expectancy of about 28 and so on through every year in our data. 

Let's say we change our mind and want to make a line chart instead. Well, all we have to do is replace `geom_point()` with `geom_line()`. 

```{r}
ggplot(data = gapminder_10_rows,
       mapping = aes(x = year,
                     y = lifeExp)) +
  geom_line()
```

Or (and now we're really getting fancy), what if we add *both* `geom_point()` and `geom_line()`? A line chart with points!  

```{r}
ggplot(data = gapminder_10_rows,
       mapping = aes(x = year,
                     y = lifeExp)) +
  geom_point() +
  geom_line()
```

We can extend this idea further, swapping in `geom_col()` to create to a bar chart. 

```{r}
ggplot(data = gapminder_10_rows,
       mapping = aes(x = year,
                     y = lifeExp)) +
  geom_col()
```

TODO: Add note that y axis changes to go to 0

I hope you're seeing how ggplot is a direct implementation of Wilkinson's grammar of graphics. The difference between a line chart and a bar chart isn't that great. Both can have the same aesthetic properties (namely, putting year on the x axis and life expectancy on the y axis), but simply use different geometric objects to visually represent the data. 

Before we return to the drought data viz, let's look at a few additional layers that can help us can alter our bar chart. Let's say we want to change the color of our bars. In the grammar of graphics approach to chart-making, this means mapping some variable to the aesthetic property of fill (slightly confusingly, the aesthetic property color would, for a bar chart, change the outline of each bar). In the same way that we mapped `year` to the x axis and y to `lifeExp`, we can also map fill to a variable. Let's try mapping fill to the year variable.

```{r}
ggplot(data = gapminder_10_rows,
       mapping = aes(x = year,
                     y = lifeExp,
                     fill = year)) +
  geom_col()
```

What we see now is that, for earlier years, the fill is darker while for later years, it is lighter (the legend, added to the right of our plot, shows this). What if we want to change the fill color? For that, we use a scale function. In this case, I'll use the `scale_fill_viridis_c()` function (the c at the end of the function name refers to the fact that the data is not continuous). This function, just one of many functions that start with `scale_` and can alter the fill scale, changes the default palette to one that is colorblind-friendly and prints well in grayscale. 

```{r}
ggplot(data = gapminder_10_rows,
       mapping = aes(x = year,
                     y = lifeExp,
                     fill = year)) +
  geom_col() +
  scale_fill_viridis_c()
```

Another layer we can use is the theme layer. This layer allows us to change the overall look-and-feel of plots (think: plot backgrounds, gridlines, etc). Just as there are a number of `scale_` functions, there are also a number of functions that start with `theme_`. Below, I've added `theme_minimal()`, my go-to theme, which gives us a much more streamlined look. 

```{r}
ggplot(data = gapminder_10_rows,
       mapping = aes(x = year,
                     y = lifeExp,
                     fill = year)) +
  geom_col() +
  scale_fill_viridis_c() +
  theme_minimal()
```

While adding `theme_minimal()` massively improves any plot, our bar chart here is not anything I would put forward as high-quality data visualization. But, at the very least, we've seen building a chart with ggplot involves working with multiple layers:

- First, we select variables to map to aesthetic properties such as x or y axis, color/fill, etc
- Second, we choose the geometric object (aka geom) we want to use to represent our data
- Third, if we want to change aesthetic properties (for example, using a different palette), we do this with a `scale_` function
- Fourth, we use a `theme_` function to set the overall look-and-feel of our plot. 

This is, of course, just scratching the surface of what is possible with ggplot. There are many ways we could improve this plot. But rather than improving an ugly plot, let's instead return to the drought data viz that Cédric Scherer and Georgios Karamanis made. Going through their code will show us some familiar aspects of ggplot -- and present some tips on how to make high-quality data visualization with R. 

## Return to plot and show how code works

TODO: Use past/present consistently

```{r}
library(tidyverse)
library(lubridate)

## Color palette hubs
greys <- c(0, 60, 40, 60, 0, 40, 60, 0)
pal1 <- paste0("grey", greys)
## Set up hubs map
hub_northwest <- c("AK", "OR", "ID", "WA")
hub_california <- "CA"
hub_southwest <- c("AZ", "HI", "NM", "NV", "UT")
hub_northern_plains <- c("CO", "MT", "ND", "NE", "SD", "WY")
hub_southern_plains <- c("KS", "OK", "TX")
hub_midwest <- c("IL", "IN", "MN", "IA", "MI", "MO", "OH", "WI")
hub_southeast <- c("AL", "AR", "LA", "MS", "TN", "KY", "GA", "NC", "FL", "GA", "SC", "VA")
hub_northeast <- c("CT", "DE", "ME", "MA", "MD", "NH", "NJ", "NY", "PA", "RI", "VT", "WV")
hubs_order <- c("Northwest", "California", "Southwest", "Northern Plains", 
                "Southern Plains", "Midwest", "Southeast", "Northeast")

## Read in DroughMonitor hub data
dm_perc_cat_hubs_raw <- rio::import(here::here("data", "dm_export_20000101_20210909_perc_cat_hubs.json"))

## Wrangle
dm_perc_cat_hubs <-
  dm_perc_cat_hubs_raw %>%
  ## Remove Northern Forest as it combines Midwest + Northeast
  filter(Name != "Northern Forests\\n") %>%
  ## Remove Carribean which shows no distinct drought patterns anyway
  filter(Name != "Caribbean") %>%
  mutate(
    across(c(MapDate, ValidStart, ValidEnd), as_date),
    across(None:D4, ~as.numeric(.x) / 100),
    Name = stringr::str_remove(Name, "\\\\n"),
    Name = str_replace(Name, "Nothern", "Northern")
  ) %>%
  rename("date" = "MapDate", "hub" = "Name") %>%
  pivot_longer(
    cols = c(None:D4),
    names_to = "category",
    values_to = "percentage"
  ) %>%
  filter(category != "None") %>%
  mutate(category = factor(category)) %>%
  dplyr::select(-ValidStart, -ValidEnd, -StatisticFormatID) %>%
  mutate(
    year = year(date),
    week = week(date),
    hub = factor(hub, levels = hubs_order, labels = hubs_order)
  ) %>%
  group_by(year) %>%
  mutate(max_week = max(week)) %>% ## for var
  ungroup() %>% 
  filter(percentage > 0)
```

The code that Cédric and Georgios wrote to make their final data viz relies on a combination of ggplot fundamentals and some less-well-known tweaks that make it really shine. In order to understand how Cédric and Georgios made their data viz, we'll start out with a simplified version of their code. We'll build it up step-by-step, adding elements until we can see exactly how they made their drought data viz. 

### Basics of ggplot

Let's start by looking again at one region (Southeast) in one year (2000). First, we filter our data and save it as a new object called `southeast_2000`. 

```{r}
southeast_2000 <- dm_perc_cat_hubs %>% 
  filter(hub == "Southeast") %>% 
  filter(year == 2000)
```
We can take a look at this object to see the variables we have to work with:

- **date**: start date of the week of the observation
- **hub**: region
- **category**: level of drought (D0 = lowest level of drought; D5 = highest level) TODO: check that my interpretation is correct
- **percentage**: percentage of that region that is in that category of drought
- **year**: observation year
- **week**: week number (i.e. first week is week 1)
- **max_week**: TODO check what it means

```{r}
southeast_2000 %>% 
  slice(1:10)
```
Now we can use this `southeast_2000` object for our plotting. In the `ggplot()` function, we tell R to put week on the x axis, percentage on the y axis, and use the category variable (i.e. drought level) for our fill color. We then use `geom_col()` to create a bar chart where the color of each bar represents the percentage of the region in a single week that is at different drought levels. The colors don't match the final version of the plot, but with this code, we can start to see the outlines of Cédric and Georgios's data viz.  

```{r}
ggplot(data = southeast_2000,
       aes(x = week, 
           y = percentage,
           fill = category)) +
  geom_col()
```

### Scales

Cédric and Georgios next select different fill colors for their bars. They use the `scale_fill_viridis_d()` function. The "d" here means the data that the fill scale is being applied to is discrete (i.e. broken into the categories D0, D1, D2, D3, D4, D5). They use the argument `option = "rocket"` in order to select the "rocket" palette (the `scale_fill_viridis_d()` function has several other palettes that can be selected). And they use the `direction = -1` argument to reverse the order of fill colors so that darker colors mean higher drought conditions. 

```{r}
ggplot(data = southeast_2000,
       aes(x = week, 
           y = percentage,
           fill = category)) +
  geom_col() +
  scale_fill_viridis_d(option = "rocket",
                       direction = -1)
```

#### x and y axes

In the language of ggplot, x and y axis are aesthetic properties, just the same as fill color. Cédric and Georgios tweak the x axis to remove both the axis title ("week") using `name = NULL` and the 0-50 axis text with `guide = none`. On the y axis, they remove the axis title and axis text (which was showing percentages in 0.00, 0.25, 0.50, 0.75 format) using `labels = NULL` (this functionally does the same thing as `guide = "none"`). They also move the axis lines themselves to the right side using `position = "right"` (they are only apparent as tick marks at this point, but will become more visible later).

```{r}
ggplot(data = southeast_2000,
       aes(x = week, 
           y = percentage,
           fill = category)) +
  geom_col() +
  scale_fill_viridis_d(option = "rocket",
                       direction = -1) +
  scale_x_continuous(name = NULL, guide = "none") +
  scale_y_continuous(name = NULL, labels = NULL, position = "right")
```

### Small Multiples

Up to this point, we've focused on one of the single plots that make up the larger data viz. But the final product that Cédric and Georgios made is actually 176 plots (22 years and 8 regions). One of the most useful features of ggplot is what's known as facetting (known more commonly in the data viz world as small multiples). With the `facet_grid()` function, we can select which variable to put in rows and which to put in columns of our facetted plot. Cédric and Georgios put `year` in rows and `hub` (region) in columns. The `switch = "y"` argument moves the year label from the right side (where it appears by default) to the left. With this code in place, we can see the final plot coming together. 


```{r fig.height = 10}
ggplot(data = dm_perc_cat_hubs,
       aes(x = week, 
           y = percentage,
           fill = category)) +
  geom_col() +
  scale_fill_viridis_d(option = "rocket",
                       direction = -1) +
  scale_x_continuous(name = NULL, guide = "none") +
  scale_y_continuous(name = NULL, labels = NULL, position = "right") +
  facet_grid(rows = vars(year), cols = vars(hub), switch = "y")
```


### Small Polishes

Incredibly, the broad outlines of the plot took us just 10 lines to create. All of the final code from here on out falls in the category of what I think of as small polishes. That's not to minimize how important they are (very) or the time it takes to create them (lots). But it is to say that a little bit of ggplot goes a long way. 

#### Theme

With that said, let's look at a few of the small polishes that Cédric and Georgios make. The first is to apply a theme. They use `theme_light()`, which removes the default gray background, changes the font to Roboto, and makes the default size of elements larger using the `base_size` argument, among other tweaks. 

```{r fig.height = 10}
ggplot(data = dm_perc_cat_hubs,
       aes(x = week, 
           y = percentage,
           fill = category)) +
  geom_col() +
  scale_fill_viridis_d(option = "rocket",
                       direction = -1) +
  scale_x_continuous(name = NULL, guide = "none") +
  scale_y_continuous(name = NULL, labels = NULL, position = "right") +
  facet_grid(rows = vars(year), cols = vars(hub), switch = "y") +
  theme_light(base_size = 18, base_family = "Roboto")
```
`theme_light()` is what's known as a "complete theme." So-called complete themes change the overall look-and-feel of a plot. But Cédric and Georgios don't stop with applying a complete theme. From there, they use the `theme()` function to make additional tweaks to what `theme_light()` gives them. 


```{r fig.height = 10}
ggplot(data = dm_perc_cat_hubs,
       aes(x = week, 
           y = percentage,
           fill = category)) +
  geom_col() +
  scale_fill_viridis_d(option = "rocket",
                       direction = -1) +
  scale_x_continuous(name = NULL, guide = "none") +
  scale_y_continuous(name = NULL, labels = NULL, position = "right") +
  facet_grid(rows = vars(year), cols = vars(hub), switch = "y") +
  theme_light(base_size = 18, base_family = "Roboto") +
  theme(
    axis.title = element_text(size = 14, color = "black"),
    axis.text = element_text(family = "Roboto Mono", size = 11),
    axis.line.x = element_blank(),
    axis.line.y = element_line(color = "black", size = .2),
    axis.ticks.y = element_line(color = "black", size = .2),
    axis.ticks.length.y = unit(2, "mm"),
    legend.position = "top",
    legend.title = element_text(color = "#2DAADA", size = 18, face = "bold"),
    legend.text = element_text(color = "#2DAADA", size = 16),
    strip.text.x = element_text(size = 16, hjust = .5, face = "plain", color = "black", margin = margin(t = 20, b = 5)),
    strip.text.y.left = element_text(size = 18, angle = 0, vjust = .5, face = "plain", color = "black"),
    strip.background = element_rect(fill = "transparent", color = "transparent"),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_blank(),
    panel.spacing.x = unit(0.3, "lines"),
    panel.spacing.y = unit(0.25, "lines"),
    panel.background = element_rect(fill = "transparent", color = "transparent"),
    panel.border = element_rect(color = "transparent", size = 0),
    plot.background = element_rect(fill = "transparent", color = "transparent", size = .4),
    plot.margin = margin(rep(18, 4))
  )
```

The code in the `theme()` function does many different things, but let's take a look at a few of the most important:

`legend.position = "top"` moves the legend from the right (the default) to the top of the plot. 

`strip.text.y.left = element_text(size = 18, angle = 0, vjust = .5, face = "plain", color = "black")` turns the year text in the columns so that it is no longer angled. 

TODO: Add image that shows before + after of this

The following lines make the distinctive axis lines and ticks that show up on the right side of the final plot. 

```{r eval = FALSE}
axis.line.x = element_blank(),
axis.line.y = element_line(color = "black", size = .2),
axis.ticks.y = element_line(color = "black", size = .2),
axis.ticks.length.y = unit(2, "mm")
```

`panel.grid.minor = element_blank()` and `panel.grid.major = element_blank()` remove all grid lines from the final plot. 

And finally, these three lines remove the borders and make each of the individual plots have a transparent background. 

```{r eval = FALSE}
panel.background = element_rect(fill = "transparent", color = "transparent"),
panel.border = element_rect(color = "transparent", size = 0),
plot.background = element_rect(fill = "transparent", color = "transparent", size = .4)
```

#### geom_rect

Keen readers such as yourself may now be thinking: "wait, didn't the individual plots have a gray background behind them?" Yes, dear reader, they did. How did Cédric and Georgios make these? They did this with a separate geom: `geom_rect()`. Here, they set some additional aesthetic properties specific to `geom_rect()` (`xmin`, `xmax`, `ymin`, and `ymax`). The result is a gray background drawn behind each small multiple. 

```{r fig.height = 10}
ggplot(data = dm_perc_cat_hubs,
       aes(x = week, 
           y = percentage,
           fill = category)) +
  geom_rect(aes(xmin = .5, 
                xmax = max_week + .5,
                ymin = -0.005, 
                ymax = 1),
            fill = "#f4f4f9", 
            color = NA, 
            size = 0.4
  ) +
  geom_col() +
  scale_fill_viridis_d(option = "rocket",
                       direction = -1) +
  scale_x_continuous(name = NULL, guide = "none") +
  scale_y_continuous(name = NULL, labels = NULL, position = "right") +
  facet_grid(rows = vars(year), cols = vars(hub), switch = "y") +
  theme_light(base_size = 18, base_family = "Roboto") +
  theme(
    axis.title = element_text(size = 14, color = "black"),
    axis.text = element_text(family = "Roboto Mono", size = 11),
    axis.line.x = element_blank(),
    axis.line.y = element_line(color = "black", size = .2),
    axis.ticks.y = element_line(color = "black", size = .2),
    axis.ticks.length.y = unit(2, "mm"),
    legend.position = "top",
    legend.title = element_text(color = "#2DAADA", size = 18, face = "bold"),
    legend.text = element_text(color = "#2DAADA", size = 16),
    strip.text.x = element_text(size = 16, hjust = .5, face = "plain", color = "black", margin = margin(t = 20, b = 5)),
    strip.text.y.left = element_text(size = 18, angle = 0, vjust = .5, face = "plain", color = "black"),
    strip.background = element_rect(fill = "transparent", color = "transparent"),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_blank(),
    panel.spacing.x = unit(0.3, "lines"),
    panel.spacing.y = unit(0.25, "lines"),
    panel.background = element_rect(fill = "transparent", color = "transparent"),
    panel.border = element_rect(color = "transparent", size = 0),
    plot.background = element_rect(fill = "transparent", color = "transparent", size = .4),
    plot.margin = margin(rep(18, 4))
  )
```

#### Legend

The final polish to highlight is the tweaks to the legend. I previously showed a simplified version of the `scale_fill_viridis_d()` function. A more complete version is as follows. The `name` argument sets the legend title and the `labels` argument determine the labels that show up in the legend. Rather than D0, D1, D2, D3, and D4, we now have Abnormally Dry, Moderate Drought, Severe Drought, Extreme Drought, and Exceptional Drought.


```{r fig.height = 10}
ggplot(data = dm_perc_cat_hubs,
       aes(x = week, 
           y = percentage,
           fill = category)) +
  geom_rect(aes(xmin = .5, 
                xmax = max_week + .5,
                ymin = -0.005, 
                ymax = 1),
            fill = "#f4f4f9", 
            color = NA, 
            size = 0.4
  ) +
  geom_col() +
  scale_fill_viridis_d(option = "rocket",
                       direction = -1,
                       name = "Category:",
                       labels = c("Abnormally Dry", "Moderate Drought", "Severe Drought", 
                                  "Extreme Drought", "Exceptional Drought")) +
  scale_x_continuous(name = NULL, guide = "none") +
  scale_y_continuous(name = NULL, labels = NULL, position = "right") +
  facet_grid(rows = vars(year), cols = vars(hub), switch = "y") +
  theme_light(base_size = 18, base_family = "Roboto") +
  theme(
    axis.title = element_text(size = 14, color = "black"),
    axis.text = element_text(family = "Roboto Mono", size = 11),
    axis.line.x = element_blank(),
    axis.line.y = element_line(color = "black", size = .2),
    axis.ticks.y = element_line(color = "black", size = .2),
    axis.ticks.length.y = unit(2, "mm"),
    legend.position = "top",
    legend.title = element_text(color = "#2DAADA", size = 18, face = "bold"),
    legend.text = element_text(color = "#2DAADA", size = 16),
    strip.text.x = element_text(size = 16, hjust = .5, face = "plain", color = "black", margin = margin(t = 20, b = 5)),
    strip.text.y.left = element_text(size = 18, angle = 0, vjust = .5, face = "plain", color = "black"),
    strip.background = element_rect(fill = "transparent", color = "transparent"),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_blank(),
    panel.spacing.x = unit(0.3, "lines"),
    panel.spacing.y = unit(0.25, "lines"),
    panel.background = element_rect(fill = "transparent", color = "transparent"),
    panel.border = element_rect(color = "transparent", size = 0),
    plot.background = element_rect(fill = "transparent", color = "transparent", size = .4),
    plot.margin = margin(rep(18, 4))
  )
```

#### Full Code

While I've showed you a nearly complete version of the code, I have made some small changes along the way to make it easier to understand. If you're curious to see the full code Cédric and Georgios used to create the data viz, here it is. There are a few additional tweaks to colors and spacing, but nothing major beyond what you've seen so far. 

```{r fig.height = 10}
 ggplot(dm_perc_cat_hubs, aes(week, percentage)) +
  geom_rect(aes(
    xmin = .5, xmax = max_week + .5,
    ymin = -0.005, ymax = 1),
    fill = "#f4f4f9", color = NA, size = 0.4, show.legend = FALSE  #9d9ca7, 99a4be, 8696bd
  ) + 
  geom_col(
    aes(fill = category, 
        fill = after_scale(addmix(darken(fill, .05, space = "HLS"), "#d8005a", .15)), 
        color = after_scale(darken(fill, .2, space = "HLS"))),
    width = .9, size = 0.12
  ) + 
  facet_grid(rows = vars(year), cols = vars(hub), switch = "y") +
  coord_cartesian(clip = "off") +
  scale_x_continuous(expand = c(.02, .02), guide = "none", name = NULL) +
  scale_y_continuous(expand = c(0, 0), position = "right", labels = NULL, name = NULL) + 
  scale_fill_viridis_d(
    option = "rocket", name = "Category:", 
    direction = -1, begin = .17, end = .97,
    labels = c("Abnormally Dry", "Moderate Drought", "Severe Drought", 
               "Extreme Drought", "Exceptional Drought")
  ) +
  guides(fill = guide_legend(override.aes = list(size = 1))) +
  theme_light(base_size = 18, base_family = "Roboto") +
  theme(
    axis.title = element_text(size = 14, color = "black"),
    axis.text = element_text(family = "Roboto Mono", size = 11),
    axis.line.x = element_blank(),
    axis.line.y = element_line(color = "black", size = .2),
    axis.ticks.y = element_line(color = "black", size = .2),
    axis.ticks.length.y = unit(2, "mm"),
    legend.position = "top",
    legend.title = element_text(color = "#2DAADA", size = 18, face = "bold"),
    legend.text = element_text(color = "#2DAADA", size = 16),
    strip.text.x = element_text(size = 16, hjust = .5, face = "plain", color = "black", margin = margin(t = 20, b = 5)),
    strip.text.y.left = element_text(size = 18, angle = 0, vjust = .5, face = "plain", color = "black"),
    strip.background = element_rect(fill = "transparent", color = "transparent"),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_blank(),
    panel.spacing.x = unit(0.3, "lines"),
    panel.spacing.y = unit(0.25, "lines"),
    panel.background = element_rect(fill = "transparent", color = "transparent"),
    panel.border = element_rect(color = "transparent", size = 0),
    plot.background = element_rect(fill = "transparent", color = "transparent", size = .4),
    plot.margin = margin(rep(18, 4))
  )
```

## Conclusion

There are all sorts of tools to make data visualization. From Excel to Tableau to niche apps for specific types of data viz, the range of tools out there is nearly limitless. So why use ggplot?

The data visualization that Cédric Scherer and Georgios Karamanis 

- Small multiples
- Well-chosen colors
- Strips away extraneous elements with theme

And all of this is possible because ggplot makes it easy
