```{r}
i <- 1
chapter_number <- 2
source("_common.R")
```

# An R Programming Crash Course {#howto-chapter}

R has a well-earned reputation for being hard to learn. Especially for those who come to R without programming experience, it can be hard to figure out how things work. This chapter is designed to help those who have never used R before. I'll start from scratch, showing you what you need to download in order to use R, and how to work with data using functions, objects, packages, and projects. If you have some experience with R, feel free to skip this chapter. But if you're just starting out, this chapter will help you understand the basics, and help you make sense of the rest of the book.

## Getting Set Up {-}

One of the more confusing things for people just starting out is that you need two pieces of software in order to use R. The first is R itself, which provides the engine that makes R work. The second is RStudio, which makes working with R much easier. The best way to understand the relationship between R and RStudio is with this analogy from the book *Modern Dive*  by Chester Ismay and Albert Kim. R is the engine that makes your work with data go. RStudio is like a dashboard that makes it easier to work with your data by providing a more user-friendly interface. 
Let's download each piece and get started. To download R, go to https://cloud.r-project.org/ and choose your operating system, as seen in Figure \@ref(fig:cran-download-r)

```{r results='asis'}
print_nostarch_file_name(file_type_to_print = "png")
```

```{r cran-download-r, out.width="100%", fig.cap="The Comprehensive R Archive Network where you can download R"}
knitr::include_graphics(here::here("assets/download-r.png"))
```

```{r results='asis'}
save_image_for_nostarch(here::here("assets/download-r.png"))
```

Once you download and install R, open it and you will see Figure \@ref(fig:r-console).

```{r results='asis'}
print_nostarch_file_name(file_type_to_print = "png")
```

```{r r-console, out.width="100%", fig.cap="The R console"}
knitr::include_graphics(here::here("assets/r-console.png"))
```

```{r results='asis'}
save_image_for_nostarch(here::here("assets/r-console.png"))
```

You can work directly in the R. For example, I can type 2 + 2, hit enter, and I will see 4. Simple math problems are only the start; you can do pretty much anything in R. No matter what you're planning to do, you're probably not super impressed with the R interface. A few brave souls work only using the command line we're looking at, but most do not. RStudio is where most R coders do their work. RStudio is like a skin that lives on top of R itself. It doesn't provide new functionality to R, but it wraps R in a much more user-friendly interface, providing a way to see your files, outputs, and more. You can download RStudio at https://posit.co/download/rstudio-desktop/. 

Install RStudio as you would any other app and open it up. You'll see that RStudio has several panels. The first time you open RStudio, you'll see these three panels:

```{r results='asis'}
print_nostarch_file_name(file_type_to_print = "png")
```

```{r rstudio-no-project, out.width="100%", fig.cap="The RStudio editor"}
knitr::include_graphics(here::here("assets/rstudio-no-project.png"))
```

```{r results='asis'}
save_image_for_nostarch(here::here("assets/rstudio-no-project.png"))
```

The left side panel should look familiar. It is what we saw when working in R. This is known as the **console**. You'll use it to add code and see results. This panel, like the others we'll discuss, has several tabs (terminal and background jobs) for more advanced usages. For now, we'll stick to the default tab. Let's look at the bottom right panel next. This **files** panel shows all of the files on my computer. Finally, the top right panel shows my **environment**. The environment is what functions and objects (both of which are discussed below) I have available to me when working in RStudio. There's one more panel that you'll typically have when working in RStudio. But to make it appear, we need to create an R script file. 

## R Script Files {-}

If you work in the console, either in RStudio or in R itself, you won't have a record of your code. Say you sit down today and write code to import your data, analyze it, and make some graphs. You don't want to have to recreate that code from scratch tomorrow. The way to save your code is by using files. There are two types of files we'll discuss in this book:

1. R script files, which only contain code.
2. R Markdown files, which contain code combined with text. 

We'll talk about R Markdown files starting in Chapter \@ref(rmarkdown-chapter). Let's start with R script files, which use the .R extension. To create an R script file, go to File > New File > R Script. When you create a new R script file, you'll now have fourth panel in the top left, which you can see in Figure \@ref(fig:rstudio-four-panels) 

```{r results='asis'}
print_nostarch_file_name(file_type_to_print = "png")
```

```{r rstudio-four-panels, out.width="100%", fig.cap="RStudio with four panels"}
knitr::include_graphics(here::here("assets/rstudio-four-panels.png"))
```

```{r results='asis'}
save_image_for_nostarch(here::here("assets/rstudio-four-panels.png"))
```

I'll save this file in my `Documents` folder as `sample-code.R`. I can now use the same syntax in my R script file that I did when working in just R. If I type `2 + 2` in the R script file and hit the **Run** button, 4 will show up in the console pane. If you're looking to learn R, it's probably not to help you figure out the answer to 2 + 2. Instead, you probably want to read in your own data and do analysis on it. Let's work with some real data. 

## Working with Data {-}

To explain how you work with data in R, we need go on a bit of a detour. We'll make stops to discuss RStudio functions, objects, packages, and projects before we import and take a look at our data.

Conceptually, working with data in R is very different than working with data in a tool like Excel. In Excel, your data and any analysis you do on it all live in the same place: a spreadsheet. With R, you typically have data that lives in some external source (for example, an Excel spreadsheet or a CSV file). In order to work with this data in R, you have to run code to import it. It's only once you've run this code, which is made up of functions, that you have the data available in R. 

## Functions {-}

Let's say I have a CSV file called `population-by-state.csv` in my `Documents` folder that I want to import to R. To import it into R, you might think to add a line like this in the `sample-code.R` file:

```{r eval = FALSE, echo = TRUE}
read.csv(file = "/Users/davidkeyes/Documents/population-by-state.csv")
```

This line shows the `read.csv()` function. Functions in R are pieces of code that you can run to achieve specific goals. Functions have a name and argument, which are surrounded by parentheses. Looking at the `read.csv()` function, the name, which appears before the open parentheses, is `read.csv`. Within the parentheses, we have the text `file = "Documents/population-by-state.csv"`. Here we can see the argument `file`. The text after the equals sign gives the location of the file we want to read in. Arguments work in this way: the argument name, followed by the equals sign, followed by some value. This allows us to do something general (like importing a CSV) while allowing us to choose the specific file to run the function on. Functions can have multiple arguments as well, each of which is separated by a comma. For example, this would read in the same file, but skip the first row.

```{r eval = FALSE, echo = TRUE}
read.csv(file = "/Users/davidkeyes/Documents/population-by-state.csv",
				 skip = 1)
```

At this point, you might think to run the code in order to import your data. You can do so by selecting the line of code and hitting the Run button (or using the keyboard shortcut Command/Control + Enter on Mac/Windows). Running this code causes this text show up in the console pane. 

```{r}
read.csv(file = "/Users/davidkeyes/Documents/population-by-state.csv")
```

This is R confirming that it read in the CSV file and showing us the data within it. You might think you are ready to work with your data in R. But in fact all you've done at this point is **display** the result of running the code that imports your data. To use the data again, you need to **save** the result of running the code to an object.

## Objects {-}

To save your data for reuse, you need to create an object. To do so, you would add to your data importing syntax from above. 

```{r eval = FALSE, echo = TRUE}
population_data <- read.csv(file = "/Users/davidkeyes/Documents/population-by-state.csv")
```

The second half of this code is what we used above, but we've added to it. In the middle you will see this: `<-`. Known as the assignment operator, it takes what follows it and assigns it to the item on the left. To the left of the assignment operator is `population_data`. This is an **object**. Put together, the whole line reads in the CSV and assigns it to an object called `population_data`. If you run this line of code, you will now see `population_data` in your environment pane, as in Figure \@ref(fig:population-data-environment).

```{r results='asis'}
print_nostarch_file_name(file_type_to_print = "png")
```

```{r population-data-environment, out.width="100%", fig.cap="An object in our environment pane"}
knitr::include_graphics(here::here("assets/population-data-environment.png"))
```

```{r results='asis'}
save_image_for_nostarch(here::here("assets/population-data-environment.png"))
```

This is confirmation that your data import worked and you have the `population_data` object ready for any future use. Now, instead of having to rerun the code to import the data, I can simply type `population_data`, run that line, and I'll see the same output as above. Data imported to an object is known as a **data frame**.

## Packages {-}

The `read.csv()` function that we've used up to this point is one of a set of functions that come from what is known as base R. They are built into R and you simply have to type the name of the function to use it. However, one of the benefits of R being an open source language is that anyone create their own code and share it with others. R users around the world make what are called **packages**, which provide code to do specific things. 

The best analogy for understanding packages also comes from the *Modern Dive*  book. The functionality in base R is like when you get a new phone. It can do a lot on its own. But you usually want to install apps on your phone to do specific things. Packages are like apps, giving you specific functionality that doesn't come built into base R.

You can install a package using the `install.packages()` function. For example, to install the `tidyverse` package, which provides a range of functions for data import, cleaning, analysis, visualization, and more, you would type `install.packages("tidyverse")`. I typically enter this code in the console because you only need to install a package once on your computer and so I know I don't need to rerun this code again. 

To confirm that the `tidyverse` package has been installed correctly, click on the packages tab on the bottom right panel. Search for `tidyverse` and you should see it pop up, as in Figure \@ref(fig:tidyverse-installed).

```{r results='asis'}
print_nostarch_file_name(file_type_to_print = "png")
```

```{r tidyverse-installed, out.width="100%", fig.cap="Confirmation that the tidyverse package is installed on my computer"}
knitr::include_graphics(here::here("assets/tidyverse-installed.png"))
```

```{r results='asis'}
save_image_for_nostarch(here::here("assets/tidyverse-installed.png"))
```

Now that we've installed the `tidyverse` package, let's use it. While you only need to install packages once per computer, you need to load packages each time you restart RStudio. You can only use functions from the `tidyverse` package if you first run the line `library(tidyverse)`. I'll go back to my `sample-code.R` file and re-import my data using a function from the `tidyverse` package. 

```{r echo = TRUE, include = FALSE}
library(tidyverse)

population_data_2 <- read_csv(file = "/Users/davidkeyes/Documents/population-by-state.csv")
```

At the top of my script I load the `tidyverse`. Then, I use the `read_csv()` function (note the `_` in place of the `.`) to import my data. This alternate function to import CSV files achieves the same goal of creating an object called `population_data_2`. If we type `population_data_2` and run the code (either by using the run button or the keyboard shortcut) you will see the output in the console. 

```{r}
population_data_2
```

The output is slightly different from what we saw above using the `read.csv()` function. It describes the output as a **tibble** and only shows us the first 10 rows. This slightly different output occurs because `read_csv()` imports the data not as a data frame, but as a tibble. Both are used to describe rectangular data like what you would see in a spreadsheet. While there are some small differences between data frames and tibbles, I'll use the terms interchangeably in this book. 

Before moving on from our discussion of packages, let me show you a bit more code so you can see that the `tidyverse` is more than just the `read_csv()` function. Below is a code snippet that calculates the mean population of all states. It does so by starting with the `population_data_2` data frame that we imported. It then uses what's known as a pipe, written with the text `%>%`. The pipe allows us to do multiple steps at once. In our case, that means starting with our data and then doing additional operations on it. The second line uses the `summarize()` function (made available when we load the `tidyverse` package) and then calculates a new variable called `mean_population` by using the `mean()` function on the `Pop` variable. 

```{r eval = FALSE, echo = TRUE}
population_data_2 %>% 
  summarize(mean_population = mean(Pop))
```

Running this code will return the mean population of all states.

```{r}
population_data_2 %>% 
  summarize(mean_population = mean(Pop))
```

The `tidyverse` has many functions that enable you to do nearly anything you could hope to do with your data. In this book, I'll introduce you to a number of packages, but the `tidyverse` is the one package you will find in every single piece of R code I write. 

## RStudio Projects {-}

So far, we've imported a CSV file from the Documents folder. But what happens if you're working with someone who has put the CSV file in, say, their Downloads folder? If they try to run our code, it won't work. There's a solution to this problem, and it's called RStudio projects. 

By working in a project, you can use what are known as **relative paths** to your files. Instead of having to write out `read_csv(file = "Documents/population-by-state.csv")`, you can put the CSV file in your project and then call it using `read_csv(file = "population-by-state.csv")`. This makes it easier for you, and enables others to use your code.

To create a new RStudio project, go to File > New Project. Select either New Directory or Existing Directory and choose where to put your project. If you choose New Directory, you'll need to specify that you want to create a new project. I'll do this and then choose a name for the new directory and where it should live. As see in Figure \@ref(fig:create-new-project), you can leave the two checkboxes that ask about creating a git repository and using `renv` unchecked (these are for more advanced purposes). 

```{r results='asis'}
print_nostarch_file_name(file_type_to_print = "png")
```

```{r create-new-project, out.width="100%", fig.cap="The RStudio prompt to create a new project"}
knitr::include_graphics(here::here("assets/create-new-project.png"))
```

```{r results='asis'}
save_image_for_nostarch(here::here("assets/create-new-project.png"))
```

Having now created this project, there are two major differences in RStudio's appearance:

First, the files pane no longer shows every file on my computer, but instead only shows files in the `example-project` directory. Right now that's just the `example-project.Rproj` file that indicates the folder contains a project. Second, at the very top right of RStudio, you can see the name of the `example-project` project (it had previously said `Project: (None)`). If you want to make sure you're working in a project, make sure you see its name here. Both of these changes can be seen in Figure \@ref(fig:rstudio-active-project) below.

```{r results='asis'}
print_nostarch_file_name(file_type_to_print = "png")
```

```{r rstudio-active-project, out.width="100%", fig.cap="RStudio with an active project"}
knitr::include_graphics(here::here("assets/rstudio-active-project.png"))
```

```{r results='asis'}
save_image_for_nostarch(here::here("assets/rstudio-active-project.png"))
```

Now that I've created a project, I'll use the Finder on my Mac computer to copy the `population-by-state.csv` file into the `example-project` directory. Once I do this, I can see it in the RStudio files pane, as in Figure \@ref(fig:rstudio-project-csv).

```{r results='asis'}
print_nostarch_file_name(file_type_to_print = "png")
```

```{r rstudio-project-csv, out.width="100%", fig.cap="A CSV file visible in the files pane in RStudio"}
knitr::include_graphics(here::here("assets/rstudio-project-csv.png"))
```

```{r results='asis'}
save_image_for_nostarch(here::here("assets/rstudio-project-csv.png"))
```

With this CSV file in my project, I can now import it more easily. As before, I'll start by loading the `tidyverse` package. After that, I can remove the reference to the `Documents` folder and import my data by simply using its name:

```{r eval = FALSE, echo = TRUE}
library(tidyverse)

population_data <- read_csv(file = "population-by-state.csv")
```

I'm able to import the `population-by-state.csv` file in this way because the RStudio project sets the **working directory** to be the root of my project. With the working directory set in this way, all references to files are relative to the `.Rproj` file at the root of the project (this is where the name relative paths comes from). Now that we're working with a project, anyone can run this code because it imports the data from a location that they are guaranteed to have on their computer. 

## How to Get Help {-}

Now that you've learned about the basics of how R works, you're probably ready to dive in. When you do, you're going to encounter errors. Everyone does, and it's just part of working in R. Learning how to get help when you do run into issues is a key part of learning to use R successfully. There are two main strategies you can use to get unstuck.

The first is to read the documentation. Help files can be a bit hard to decipher but at their core, they tell you what package the function comes from, what it does, its arguments, and some examples of how to use it. For additional guidance on reading documentation, I recommend the appendix of Kieran Healy's book *Data Visualization: A practical introduction* (a free online version is available at https://socviz.co/appendix.html).

In addition to providing help files in RStudio, many R packages have documentation websites. I find these easier to read and tend to use them when I am confused about how to use a function. In addition, many packages have longer articles known as vignettes that provide an overview of how the package works. Reading these can help you see how individual functions can be used in the context of a larger project. Every package I discuss in this book has a good documentation website. 


## Conclusion {-}

Getting started with R can be challenging. I myself experienced many confusions early on that I've since realized are quite common. This chapter has, hopefully, helped you to see how you can get started with R. Understanding how functions, objects, packages, and projects work is key to ensuring that you can successfully use R to work with your data. 

If R feels challenging, just know that it will get better with time. Best of all, the time you invest in learning to use R will repay itself many times over. My favorite example to show this is one I discuss in Chapter \@ref(parameterized-reporting-chapter), which discusses a technique called parameterized reporting to automatically produce dozens, hundreds, or even thousands of reports at once. At my company, R for the Rest of Us, we worked with a client to produce reports on demographics and housing data for each of the 170 plus towns and counties in the state of Connecticut. Doing this by hand would have taken the client hundreds of hours. Using R, we were able to automate the process so they can generate the reports simply by running code. If you make multiple reports by hand, think of the hours you're spending. Reframe the time it takes to learn R as an investment in never having to do this manual labor again. When you're struggling to make sense of an inscrutable error message, it may not feel like it's worth the effort to learn R. But, with all of the time R will save you, I promise it is.

