```{r}
i <- 1
chapter_number <- 10
source("_common.R")
```

# Embracing Quarto, the Next-Generation Tool for Reproducible Reporting

In mid-2022, the team at Posit (the company that makes the RStudio editor, the `tidyverse`, and many other tools to support R programmers) made an announcement: they had developed a new tool called Quarto, which they described as the next-generation version of R Markdown. Why did Posit feel the need to develop a new tool for reproducible reporting? They cited a few reasons:

1. **More consistent syntax**: As you've seen in this book, the syntax used to create different outputs with R Markdown varies. For example, the `distill` package has layout options that don't work in `xaringan`. And `xaringan` uses three dashes to indicate new slides, while three dashes in other output formats would create a horizontal line. With Quarto, the idea is to make the syntax used to create different outputs more consistent. 
2. **Support for multiple languages**: While R Markdown does work with languages such as Python, having the word R in the name was off-putting for non-R users. Creating a tool like Quarto was Posit's "attempt to bring R Markdown to everyone." What's more Quarto makes it straightforward for users to include code from multiple languages in a single document. 
3. **Support for multiple code editors**: R Markdown is designed to work in the RStudio IDE. With the move to support additional languages, it was important to support the code editors that users of those languages prefer. Quarto works in RStudio as well as editors such as VS Code, JupyterLab, and others. 

While the benefits of Quarto are clearest for non-R users, there are also many reasons why R users may want to use Quarto. I'll focus in this chapter on the benefits for R users who use RStudio. I'll begin by explaining how to set up and use Quarto. We'll focus on some of the most important differences between Quarto and R Markdown. I'll then demonstrate how to make each of the products we made in R Markdown with Quarto. Parameterized reporting, presentations, and websites are all things that Quarto can do, and this chapter will show you how.

## Getting Started with Quarto {-}

To get started with Quarto, we need to first install it. The good news is that newer versions of RStudio (2022.07.1 and later) come with Quarto installed. To check your RStudio version, click RStudio in the top menu bar, then click About RStudio.  If you have an older version of RStudio, update it now and Quarto will be installed for you.

Once you have Quarto installed, you're ready to work with it. We'll create a Quarto document by clicking File > New File > Quarto Document. You'll see a menu, shown in Figure \@ref(fig:TODO), that looks like what you saw when creating an R Markdown document.

TODO: Add screenshot

I'll give my document a title and choose HTML as my output format. The engine option allows users to select a different way to render documents. I'll keep the default of `Knitr`, which is the same tool that R Markdown uses to render documents. I'll keep the Use visual markdown editor unchecked (this option allows you to use an interface that looks more like Microsoft Word). The Quarto document that is created has default content, just like R Markdown documents. 

````{verbatim echo = TRUE, eval = FALSE, lang = "markdown"}
---
title: "My Report"
format: html
---

## Quarto

Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see <https://quarto.org>.

## Running Code

When you click the **Render** button a document will be generated that includes both content and the output of embedded code. You can embed code like this:

```{r}
1 + 1
```

You can add options to executable code like this 

```{r}
#| echo: false
2 * 2
```

The `echo: false` option disables the printing of code (only output is displayed).
````

There are some differences between R Markdown and Quarto and many things in common. Let's explore them.

## Comparing R Markdown and Quarto {-}

Looking through our newly created Quarto document, you can see how similar Quarto and R Markdown are overall. Both have the same basic structure: YAML metadata, followed by a combination of markdown text and code chunks. Despite the similarities, there are some differences. In R Markdown, we would have created an HTML document with this YAML. 

```
---
title: "My Report"
output: html_document
---
```

With Quarto, `output` is replaced with `format` and we write `html` instead of `html_document`.

```
---
title: "My Report"
format: html
---
```

A second difference between R Markdown and Quarto is that the `setup` code chunk seen in the former does not exist in the latter. Recall from Chapter \@ref(rmarkdown-chapter) that the `setup` code chunk sets default options on things like whether we show code, charts and tables, and other elements in the rendered versions of our documents. With Quarto, these options are set in the YAML. For example, if we want to hide code as well as all warnings and messages from out rendered document, we add them under `execute` in our YAML as follows (Quarto also allows you to write true and false in lower case):

```
---
title: "My Report"
format: html
execute:
  echo: false
  warning: false
  message: false
---
```

In R Markdown, if we want to override options at the individual code chunk level, we do it as follows. The code chunk below would show both the code `2 * 2` as well as the output (4).

````{verbatim echo = TRUE, eval = FALSE, lang = "markdown"}
```{r echo = TRUE}
2 * 2
```
````

With Quarto, we use a slightly different syntax to set individual chunk-level options. You can see below how the chunk option is not set within the curly brackets, but instead in the code chunk itself. We use the text `#|` (this is known as the **hash pipe**) at the start of a line to indicate that we are setting options. 

````{verbatim echo = TRUE, eval = FALSE, lang = "markdown"}
```{r}
#| echo: false
2 * 2
```
````

A final difference you're likely to see if you switch from R Markdown to Quarto is that option names that consist of two words are separated by a dash rather than a period. R Markdown, for example, uses the code chunk option `fig.height` to determine the height of plots.

````{verbatim echo = TRUE, eval = FALSE, lang = "markdown"}
```{r fig.height = 10}
library(palmerpenguins)
library(tidyverse)

ggplot(penguins, aes(x = bill_length_mm,
                     y = bill_depth_mm)) +
  geom_point()
```
````

In contrast, Quarto uses `fig-height` as follows. 

````{verbatim echo = TRUE, eval = FALSE, lang = "markdown"}
```{r}
#| fig-height: 10

library(palmerpenguins)
library(tidyverse)

ggplot(penguins, aes(x = bill_length_mm,
                     y = bill_depth_mm)) +
  geom_point()
```
````

Helpfully for those of us coming from R Markdown, `fig.height` and similar options with periods in them will continue to work if you forget to make the switch. A list of all code chunk options can be found on the Quarto website: https://quarto.org/docs/reference/cells/cells-knitr.html. 

Rendering your Quarto document to HTML (or any other format) follows the same process as R Markdown. While you use the Knit button to render an R Markdown document, with Quarto the button is called Render. Figure \@ref(fig:TODO) shows both buttons.

TODO: Add screenshot

Clicking the Render button will turn the Quarto document I created above into an HTML file, seen in Figure \@ref(fig:TODO).

TODO: Add screenshot

As you've seen, the differences between R Markdown and Quarto are mostly around syntax. All of the general concepts you learned about generating reports with the single-tool workflow described in Chapter \@ref(rmarkdown-chapter) apply to Quarto as well.

## Making Different Types of Outputs with Quarto {-}

Now that you've learned how Quarto works, let's make a few different things with it. We'll go through the outputs that you've seen how to develop in Chapters \@ref(parameterized-reporting-chapter), \@ref(presentations-chapter), and \@ref(websites-chapter).

### Parameterized Reporting with Quarto {-}

Let's start with parameterized reporting. The process of making parameterized reports with Quarto is nearly identical to how it's done with R Markdown. Below, I've taken the R Markdown document used to make the Urban Institute COVID Report in Chapter \@ref(parameterized-reporting-chapter) and adapted it for Quarto. I did so by copying the `.Rmd` file and changing its extension to `.qmd`. From there, I made the following changes:

1. Switched `output: html_document` to `format: html` in the YAML.
2. Removed the `setup` code chunk and put the options that were there in the YAML.
3. Switched the `fig.height` option in the last code chunk to `fig-height` and used the hash pipe. 

````{verbatim echo = TRUE, eval = FALSE, lang = "markdown"}
---
title: "Urban Institute COVID Report"
format: html
params:
  state: "Alabama"
execute:
  echo: false
  warning: false
  message: false
---

```{r}
library(tidyverse)
library(urbnthemes)
library(here)
library(scales)
```

# `r params$state`

```{r}
cases <- tibble(state.name) %>%
  rbind(state.name = "District of Columbia") %>%
  left_join(read_csv("https://data.rwithoutstatistics.com/united_states_covid19_cases_deaths_and_testing_by_state.csv", skip = 2),
            by = c("state.name" = "State/Territory")) %>%
  select(total_cases = `Total Cases`, state.name,
         cases_per_100000 = `Case Rate per 100000`) %>%
  mutate(cases_per_100000 = parse_number(cases_per_100000)) %>% 
  mutate(case_rank = rank(-cases_per_100000, ties.method = "min"))
```

```{r}
state_text <- if_else(params$state == "District of Columbia", str_glue("the District of Columbia"), str_glue("state of {params$state}"))

state_cases_per_100000 <- cases %>%
  filter(state.name == params$state) %>% 
  pull(cases_per_100000) %>% 
  comma()

state_cases_rank <- cases %>%
  filter(state.name == params$state) %>% 
  pull(case_rank)
```

In `r state_text`, there were `r state_cases_per_100000` cases per 100,000 people in the last seven days. This puts `r params$state` at number `r state_cases_rank` of 50 states and the District of Columbia. 

```{r}
#| fig-height: 8

set_urbn_defaults(style = "print")

cases %>% 
  mutate(highlight_state = if_else(state.name == params$state, "Y", "N")) %>% 
  mutate(state.name = fct_reorder(state.name, cases_per_100000)) %>% 
  ggplot(aes(x = cases_per_100000,
             y = state.name,
             fill = highlight_state)) +
  geom_col() +
  scale_x_continuous(labels = comma_format()) +
  theme(legend.position = "none") +
  labs(y = NULL,
       x = "Cases per 100,000")
```
````

Despite these small differences, when rendered the report looks almost exactly the same as the one we produced in Chapter \@ref(parameterized-reporting-chapter). Also nearly identical is the process of creating one report for each state. We can take the `render.R` script file we used to make parameterized reports in Chapter \@ref(parameterized-reporting-chapter) and, with a few small tweaks, it works. In the updated `render.R` file below, I made the following tweaks:

1. Load the `quarto` package instead of the `rmarkdown` package.
2. Made the input file `urban-covid-budget-report.qmd` instead of `urban-covid-budget-report.Rmd`.
3. In the `reports` tibble I created, used `execute_params` instead of `params`.
4. On the last line, used the `quarto_render()` function instead of the `render()` function from the `markdown` package.

````{verbatim echo = TRUE, eval = FALSE, lang = "r"}
# Load packages
library(tidyverse)
library(quarto)

# Create a vector of all states and the District of Columbia
state <- tibble(state.name) %>%
  rbind("District of Columbia") %>% 
  pull(state.name)

# Create a tibble with information on the:
# input R Markdown document
# output HTML file
# parameters needed to knit the document
reports <- tibble(
  input = "urban-covid-budget-report.qmd",
  output_file = str_glue("{state}.html"),
  execute_params = map(state, ~list(state = .))
)

# Generate all of our reports
reports %>%
  pwalk(quarto_render)
````

Just as in Chapter \@ref(parameterized-reporting-chapter), running this code will produce one report for each state. 

### Presentations {-}

Quarto can also produce presentations like those we made in Chapter \@ref(presentations-chapter). Again, the process is nearly identical to how we made slides with the `xaringan` package. To make a presentation with Quarto, click on File > New File > Quarto Presentation. You'll want to choose Reveal JS to make your slides and leave the Engine and Editor options untouched, as seen in Figure \@ref(fig:TODO).

TODO: Add screenshot

The slides we'll make use the reveal.js javascript library under the hood. Making slides in this format is the Quarto approach that is most similar to making slides with `xaringan`. Below I've taken the code used to make a presentation with `xaringan` in Chapter \@ref(presentations-chapter) and made a few updates to make it work with Quarto. 

````{verbatim echo = TRUE, eval = FALSE, lang = "markdown"}
---
title: "Penguins Report"
author: "David Keyes"
format: revealjs
execute: 
  echo: false
  warning: false
  message: false
---

# Introduction

```{r}
library(tidyverse)
```

```{r}
penguins <- read_csv("https://raw.githubusercontent.com/rfortherestofus/r-without-statistics/main/data/penguins-2008.csv")
```

We are writing a report about the **Palmer Penguins**. These penguins are *really* amazing. There are three species:

- Adelie
- Gentoo
- Chinstrap

## Bill Length

We can make a histogram to see the distribution of bill lengths.

```{r}
penguins %>% 
  ggplot(aes(x = bill_length_mm)) +
  geom_histogram() +
  theme_minimal()
```

```{r}
average_bill_length <- penguins %>% 
  summarize(avg_bill_length = mean(bill_length_mm,
                                   na.rm = TRUE)) %>% 
  pull(avg_bill_length)
```

The chart shows the distribution of bill lengths. The average bill length is `r average_bill_length` millimeters.
````

When we render this, we get an HTML file with our slides, seen in Figure \@ref(fig:TODO) below. 

TODO: Add screenshot

Overall, the output looks similar to the default `xaringan` slides we made. However, remember how we had to manually add three dashes to make slides with `xaringan`? With Quarto, any first- or second-level headers make new slides (you can also use three dashes to make a slide break).

Quarto slides also make it possible to incrementally reveal content. Bulleted and numbered lists can be made to incrementally reveal by default by adjusting the YAML. See here how I add `incremental: true` to the YAML.

````{verbatim echo = TRUE, eval = FALSE, lang = "markdown"}
---
title: "Penguins Report"
author: "David Keyes"
format: 
  revealjs:
	  incremental: true
execute: 
  echo: false
  warning: false
  message: false
---
````

When I do this, the content in all lists in my presentation will be revealed one item at a time. You can also set just some lists to incrementally reveal using this format:

````{verbatim echo = TRUE, eval = FALSE, lang = "markdown"}
::: {.incremental}
- Adelie
- Gentoo
- Chinstrap
:::
````

This pattern using `:::` to start and end a section creates a section in the resulting HTML file known as a `<div>`. The HTML `<div>` tag allows you to define properties within that section. In the code above, adding `{.incremental}` sets a custom CSS class that makes the list reveal incrementally. 

We see a similar pattern when creating columns in Quarto slides. Let's say we want to create a slide with content in two columns, as in Figure \@ref(fig:TODO).

TODO: Add screenshot.

The code below is what I used to create the two-column slide. You'll see the `:::` as well as `::::`. This creates nested divs. We first have a `columns` class, which tells the HTML that all content within the `::::` should be laid out as columns. Then, we use `::: {.column width="50%"}` to start a div that takes up half of the width of the slide. With both `::::` and `:::`, we have to also have a matching closing `::::` and `:::` to indicate the end of the section.

````{verbatim echo = TRUE, eval = FALSE, lang = "markdown"}
:::: {.columns}

::: {.column width="50%"}
Adelie
:::

::: {.column width="50%"}
Gentoo
:::

::::
````

With `xaringan` we were also able to easily center content on our slides by surrounding it with `.center[]`. Doing the same thing in Quarto is slightly more complicated. Quarto has no built-in CSS class to center content so we need to define it ourselves. I begin by creating a CSS code chunk and creating a custom class called `center-slide`. Using a bit of CSS, I tell it to center align all content (despite it saying `text-align` you'll see that it also aligns images).

````{verbatim echo = TRUE, eval = FALSE, lang = "css"}
```{css}
.center-slide {
	text-align: center;
}
```
````

I then apply the new `center-slide` class by putting it next to the title of the slide as follows.

````{verbatim echo = TRUE, eval = FALSE, lang = "css"}
## Bill Length {.center-slide}
````

With our custom CSS applied, the slide now has all of its content centered, as seen in Figure \@ref(fig:TODO).

TODO: Add screenshot

Working in `xaringan` we added a background image to one of our slides. We can do the same in Quarto by applying the `background-image` attribute to a slide as follows.

````{verbatim echo = TRUE, eval = FALSE, lang = "css"}
## Penguins {background-image="penguins.jpg"}
````

This will add a slide with the text Penguins in front of an image of penguins, as seen in Figure \@ref(fig:TODO).

TODO: Add screenshot

### Websites {-}

## New Features in Quarto {-}

- Columns
- Extensions

# Conclusion {-}

