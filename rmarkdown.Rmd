# Use RMarkdown to Communicate Accurately and Efficiently {#rmarkdown-chapter}

Imagine this scenario. It's January, you've collected some surveys, and now you're ready to do your data analysis and write up your results. Your workflow may look something like this:

1. Download your data from Google Sheets import it into SPSS. 
2. Use SPSS to do your data cleaning and analysis. 
3. Export summaries of your data as Excel spreadsheets.
4. Use Excel to make some charts.
5. Write your report in Word, copying in your charts from Excel along the way.

Sound familiar? If so, you're not alone. It's the workflow that many people use when doing data analysis. But what happens when new surveys roll in and you have to redo your analysis in February? Yup, back through steps one through six. Same thing in March. And April. You get the idea.

You may be thinking: okay, but the multitool workflow can work for a one-time project, right? Maybe, but let's be honest: few projects are really one-time. Either you have to redo them the next month or you realize you forgot to include a few surveys in your original analysis or you realize you made a mistake in SPSS that means you need to redo steps one through six. 

RMarkdown is the solution to this problem. It combines data analysis, data visualization, and anything you can do with code (all the pieces you might do in SPSS and Excel in the multitool workflow above) alongside narrative text (the Word piece). Your combination code and text RMarkdown document can be exported to many formats, including Word, PDF, and HTML, so that you can share them with non-R users. 

By combining all of the pieces from the multitool workflow in a single tool, your workflow becomes way more efficient. Need to recreate that January report in February? Just rerun your code and you've got a new report, complete with the newest data. Need to add in a few surveys you missed at any point? Rerun your code and generate a new report. Need to fix an error in your analysis? Make the fix to your code, rerun it, and your corrected report is ready to go. 

In this chapter, we'll begin by breaking down the pieces of RMarkdown documents. We'll then talk about some potential pitfalls and best practices when using RMarkdown. And we'll conclude with some reflections on the value of the RMarkdown workflow.

## How RMarkdown Works {-}

To create an RMarkdown document while working in RStudio, you go to File > New File > RMarkdown. You can choose the title, author, and date as well as your default output format (HTML, PDF, or Word). All of these can be changed later. 

[TODO: add screenshot]

Hit OK and RStudio will create an RMarkdown document with some placeholder content. My first step is always to delete the content and replace it with my own. I'm going to create a report on penguins using data from the `palmerpenguins` package. Here is the content I'll add to my RMarkdown document.

````{verbatim}
---
title: "Penguins Report"
author: "David"
date: "2023-01-12"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(include = TRUE, 
                      echo = FALSE,
                      message = FALSE,
                      warning = FALSE)
```

```{r}
library(tidyverse)
```

```{r}
penguins <- read_csv("https://raw.githubusercontent.com/rfortherestofus/r-without-statistics/main/data/penguins-2007.csv")
```


# Introduction

We are writing a report about the **Palmer Penguins**. These penguins are *really* amazing. There are three species:

- Adelie
- Gentoo
- Chinstrap

![](penguins.png)

## Bill Length

![](culmen_depth.png)

We can make a histogram to see the distribution of bill lengths.

```{r}
penguins %>% 
  ggplot(aes(x = bill_length_mm)) +
  geom_histogram() +
  theme_minimal()
```



```{r}
average_bill_length <- penguins %>% 
  summarize(avg_bill_length = mean(bill_length_mm,
                                   na.rm = TRUE)) %>% 
  pull(avg_bill_length)
```

The chart shows the distribution of bill lengths. The average bill length is `r average_bill_length` millimeters.
````

This document has several pieces, each of which we will discuss below. For now, though, let's skip straight to the finish line by doing what's called knitting (also known as rendering or, in more plain English, exporting) our document. If we hit the knit button at the top of RStudio, our RMarkdown document is converted into whatever format we selected upon creating it.

[TODO: Add knit button screenshot]

I set the output format to be Word so I now have a Word document that I can open. 

[TODO: Add screenshot]

There are some things that were not visible in RMarkdown but are in Word (the histogram, for example). This is because our RMarkdown document did not include this plot directly, but instead had the code needed to produce the plot, which is then produced when we knit our document. 

If you write directly in a Word document, all of your text is visible right next to any charts that you add directly to this document. It may seem convoluted to constantly knit RMarkdown documents to Word, but this workflow is what allows us to update our reports at any point with updated code or new data. This is known as reproducibility, and it is central to the value of RMarkdown. But before we discuss reproducibility in depth, let's make sure we understand how RMarkdown documents are structured.

## RMarkdown Documents Structure {-}

All RMarkdown documents have three main pieces:

1. YAML
2. R code chunks
3. Markdown text

[TODO: add image showing each piece]

Let's take these pieces one at a time.

### YAML {-}

The YAML is the very first piece at the top of our RMarkdown document (the name YAML comes from the recursive acronym "YAML ain't markup language" whose meaning is not important for our purposes). With three dashes indicating its beginning and end, the text inside of the YAML contains metadata about the RMarkdown document. My YAML, shown below, tell us the title, author, date, and the output format for when we knit.

````{verbatim}
---
title: "Penguins Report"
author: "David Keyes"
date: "2023-01-12"
output: word_document
---
````

### R Code Chunks {-}

Listen to the name RMarkdown and you get a sense of the other two pieces of an RMarkdown document: R code and Markdown text. Let's discuss the R code first.

If you've only ever worked in R script files (they use the extension .R), you'll need to reorient your thinking. In R script files everything is treated as code unless you comment it out by putting a # in front of it. In the code below, the first line is a comment while the second line is code.

```{r eval = FALSE}
# Import our data
data <- read_csv("data.csv")
```

In RMarkdown, the situation is reversed. After the YAML, everything is treated as text unless we specify otherwise. And we do this specifying by creating what are known as code chunks. These start with three back ticks, followed by the lower case letter r surrounded by curly brackets. Three back ticks indicate the end of the code chunk. 

````{verbatim}
```{r}
library(tidyverse)
```
````

Working in RStudio, code chunks have a light gray background. 

[TODO: add image]

Anything between the beginning and end of the code chunk is treated as R code. The code in this code chunk will be run when we knit our document, giving us a histogram in our Word document.

````{verbatim}
```{r}
penguins %>% 
  ggplot(aes(x = bill_length_mm)) +
  geom_histogram() +
  theme_minimal()
```
````

#### Code Chunk Options

TODO: Adjust this section

You may be wondering what the `echo=FALSE` in the code chunk above is for. Code chunks have options, which determine what happens when we knit our document. The `echo` option determines whether the code itself will show up in our Word, HTML, or PDF document when we knit. Other common options are:

- `include`: Do you want to show the output of the code chunk? In the case of the chunk above, that would be the plot.
- `message`: Do you want to include any messages that code generates? TODO: add example
- `warning`: Do you want to include any messages that code generates? TODO: add example

In cases where you're using RMarkdown to generate a report for a non-R user, you likely want to hide the code, messages, and warnings but show output. You can do this in each code chunk, as above. There is also a special code chunk where we set global code chunk options. This code chunk has the `setup` and all global chunk options are set within it. The `echo = TRUE` option in the default content makes all code show up when we knit, unless this global chunk option is overwritten by an individual chunk option.

````{verbatim echo = TRUE}
```{r pressure, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
````

In the document we've been working with, `echo` is set to TRUE at the global level. However, in the code chunk called `pressure`, this option is overwritten because of the `echo = FALSE`, which, as the text below it says, "prevent[s] printing of the R code that generated the plot."

This may all feel very confusing so let me make it simple. In cases where you want to share results but hide code, messages, and warnings, my `setup` code chunk always looks like this:

````{verbatim}
```{r pressure, echo=FALSE}
knitr::opts_chunk$set(include = TRUE, 
echo = TRUE,
message = FALSE,
warning = FALSE)
```
````

Use that for your `setup` code chunk and you'll be all set.

### Markdown Text {-}

We've discussed the R portion of RMarkdown. Let's now discuss markdown. Markdown is a way to write using only plain text. If you look at the text sections (they have a plain white background) in our RMarkdown document, you can see how markdown is converted into what we see in our Word document after knitting. 

The text `# Introduction` in RMarkdown gets converted into a Heading 1 while `## Bill Length` becomes a Heading 2. You can go all the way down to Heading 6 by using six hashes. Working in RStudio headers are easy to find because they show up in blue.

Text without anything before it becomes body text in Word. If you want to make words italics, add single asterisks around them (*really*). To make them bold, use double asterisks (**Palmer Penguins**).

You can make lists by placing a dash at the beginning of a line and adding your text after it.

````{verbatim echo = TRUE}
- Adelie
- Gentoo
- Chinstrap
````

To make ordered lists you'd do the same but replacing the dashes with numbers. You can either put increasing numbers or, as I've done below, just keep repeating 1. On knitting, the numbers will be converted to 1, 2, 3, and so on.

````{verbatim echo = TRUE}
1. Adelie
1. Gentoo
1. Chinstrap
````

If you've never used markdown before, let me explain the why

### Inline R Code {-}

## Example of Re-Running Code with New Data {-}

### Best Practices {-}

Code within code chunks can be run in two ways: 

The first is to run code chunks manually (also known as running code interactively). If run the `pressure` code chunk manually, you'll see the plot in Figure \@ref(fig:CHUNKNAME). 

TODO: Add plot

The second way to run code chunks is by "knitting" (exporting) the document. When you do this, all code chunks are run (we'll discuss this more soon).

## Conclusion

- Quarto
- Reproducibility
