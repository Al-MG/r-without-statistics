# Make Tables That Look Good and Share Results Effectively 

In his book *Fundamentals of Data Visualization*, Claus Wilke writes that "tables are an important tool for visualizing data." This statement might seem might odd. Tables are often seen as the opposite of data visualization: plots are (or should be) highly-designed tools of communication; tables are where we dump numbers for the few nerds who care to read them. But Wilke sees things differently. Tables should not be data dumps devoid of design. He writes: "because of their apparent simplicity, they may not always receive the attention they need." 

Tables should be treated as data visualization because *that is exactly what they are*. As the term data visualization has become codified, it has become a synonym for graphs. But think about what the phrase data visualization really means. Don't overthink it. It simply means to visualize data. And while bars, lines, and points in graphs are visualizations, so too are numbers in a table. When we make tables, we visualize our data. 

And since we're visualizing data, we should care about design. Need proof that good design matters when it comes to making tables? Look at tables made by reputable news organizations.

TODO: Add some kind of table here? But permissions ugh.

Data dumps these are not. News organizations, whose job is to communicate clearly and effectively, pay a lot of attention to table design. 

We saw in Chapter \@ref(data-viz-chapter) that a few simple but significant tweaks can drastically improve the quality of our graphs. In this chapter, we'll see that a little bit of work can go a long way toward improving our tables. 

The good news for you is that R is a great tool for making high-quality tables. If you are writing reports in RMarkdown (which you can learn about in \@ref(rmarkdown-chapter)), you can write code that will generate a table when you export your document. Working with the same tool to generate tables alongside your text and data visualization means you don't have to copy and paste your data, running the risk of human error. 

Generating tables in Microsoft Word, the tool that many use to make tables, has other potential pitfalls. Claus Wilke found that his version of Word had 105 built-in table styles. Of those, around 80 percent violated some key principles of table design. Wilke writes: 

> So if you pick a Microsoft Word table layout at random, you have an 80% chance of picking one that has issues. And if you pick the default, you will end up with a poorly formatted table every time.

In R, there are a number of packages to make a wide range of tables. And within these packages, there are a number of functions designed to make sure your tables follow important design principles. 

The rest of this chapter will examine what these design principles are and show how to apply them in your tables made in R. We'll begin by with a brief trip into the world of table design. After examining the principles that Claus Wilke and other experts recommend, we'll learn how to apply these principles. 

For this chapter, I spoke with Tom Mock of Posit (the company that makes RStudio), who has become something of an R table connoisseur. His 2020 blog post "10+ Guidelines for Better Tables in R" takes table design principles and shows how to implement them using the `gt` package. We'll walk through examples of Tom's code to show how small tweaks can make a big difference in improving your tables.

## Table Design Principles {-}

Advice on data visualization has become ubiquitous in the last few years. Books, articles, blog posts, and more talk about how to make your graphs communicate effectively. Table design advice is less common, but it is out there. In addition to Claus Wilke, others including Jon Schwabish and Stephen Few have written about table design. All three of these experts come to discussing tables after having written about making effective graphs. The principles they discuss, not surprisingly, will sound similar to data visualization advice. The principles of effective communication apply no matter the form in which data is ultimately presented. 

The principles below are adapted primarily from my conversation with Tom Mock, which focuses on his tables blog post. That blog post shows how to implement in R the ten table design principles that Jon Schwabish discusses in his article "Ten Guidelines for Better Tables." Schwabish cites Stephen Few's work on table design. As you can see, the world of table design is closely connected. Rather than trying to and show every single principle that Schwabish discusses and Mock implements in R, I've selected what I think are the most important six. 

The code below relies on the `gt` package. This is one of the most popular table-making packages (TODO Add others here?) and, as we'll see below, it uses good design principles by default. The code below is a lightly adapted version of the code in Mock's blog post. 

### Principle One: Minimize Clutter {-}

As with data visualization, one of the most important principles of table design is to minimize clutter. One of the most important ways we can do this is by removing unnecessary elements. One of the most common unnecessary elements that clutter tables is gridlines. To show you how we can make more effective tables by removing gridlines, let's first load the packages we need. We're relying on the `tidyverse` package for general data manipulation functions, `gapminder` for the data we'll use, and `gt` to make the tables.

```{r}
library(tidyverse)
library(gapminder)
library(gt)
```

As we saw in \@ref(data-viz-chapter), the `gapminder` package gives data on country-level demographic statistics. To make a data frame we'll use for our table, let's use just a few countries (the first four in alphabetical order: Afghanistan, Albania, Algeria, and Angola). We then select the relevant variables. The `gapminder` data has variables for country, continent, year, life expectancy, population, and GDP. We'll select only country, year, and life expectancy. Next, we use the `pivot_wider()` function to put our data into the wide format that tables often use. Finally, we select only three years (1952, 1972, and 1992). The `gapminder` data has many years but we only need a few to demonstrate table-making principles. 

```{r}
life_expectancy <- gapminder %>% 
  filter(country %in% c("Afghanistan", "Albania", "Algeria", "Angola")) %>% 
  select(country, year, lifeExp) %>% 
  pivot_wider(id_cols = country,
              names_from = year,
              values_from = lifeExp) %>% 
  select(country, `1952`, `1972`, `1992`) %>% 
  rename(Country = country)
```

We save this data frame as `life_expectancy` and we can take a look at it. 

```{r}
life_expectancy
```

Now that we've created the data frame we can work with, it's time to talk about reducing clutter by getting rid of gridlines. Often, you see tables that look like this:


```{r}
life_expectancy %>% 
  gt() %>% 
  tab_style(
    style = cell_borders(
      side = "all",
      color = "grey",
      weight = px(1),
      style = "solid"
    ),
    locations = list(
      cells_body(
        everything()
      ),
      cells_column_labels(
        everything()
      )
    )
  )
```

Having gridlines around every single cell in our table is unnecessary and creates visual clutter that distracts from the goal of communicating clearly. A table with minimal or even no gridlines is a much more effective communication tool. 

```{r}
life_expectancy %>% 
  gt()
```

You know how I mentioned before that `gt` uses good table design principles by default? This is a great example of it. The second table, with minimal gridlines, requires just two lines. We pipe our `life_expectancy` data into the `gt()` function, which creates a table. 

```{r echo = TRUE, include = FALSE}
life_expectancy %>% 
  gt()
```

To make the example with gridlines everywhere, we would have to add additional code. The code that follows `gt()` here adds gridlines. Since I don't recommend doing this, I won't walk through the code. The important thing to remember is that you get good defaults using `gt()`. Take advantage of them!

```{r echo = TRUE, include = FALSE}
life_expectancy %>% 
  gt() %>% 
  tab_style(
    style = cell_borders(
      side = "all",
      color = "grey",
      weight = px(1),
      style = "solid"
    ),
    locations = list(
      cells_body(
        everything()
      ),
      cells_column_labels(
        everything()
      )
    )
  )
```

If we wanted to remove additional gridlines, we could use the following code. The `tab_style()` function uses a two-step approach:

1. Identify the style we want to modify (in this case the borders).
1. Tell the function where to apply these styles.

Here, we tell `tab_style()` that we want to modify the borders using the `cell_borders()` function, making our borders transparent. Then, we say that we want this to apply to the `cells_body()` location (other options include `cells_column_labels()` for the row with country, 1952, 1972, and 1992). 

```{r}
life_expectancy %>% 
  gt() %>% 
  tab_style(
    style = cell_borders(color = "transparent"),
    locations = cells_body()
  )
```


### Principle Two: Differentiate the Header from the Body {-}

While reducing clutter is an important goal, going too far can have negative consequences. A table with no gridlines at all can make it hard to differentiate between the header row and the table body. 

```{r}
life_expectancy %>% 
  gt() %>% 
  opt_table_lines(extent = "none")
```

We saw how to use appropriate gridlines above. We can add bolding to our header row to make it stand out even more. Again, we do this with the `tab_style()` function two-step, first saying we want to alter the text (using the `cell_text()` function) by setting the weight to bold and then saying we want this to happen only to the header row (using the `cells_column_labels()` function).

```{r}
life_expectancy %>% 
  gt() %>% 
  tab_style(
    style = cell_borders(color = "transparent"),
    locations = cells_body()
  ) %>% 
 tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_column_labels()
  )
```



### Principle Three: Align Appropriately {-}

### Principle Four: Use the Right Level of Precision {-}

### Principle Five: Use Color Intentionally {-}

### Principle Six: Add Data Visualization Where Appropriate {-}